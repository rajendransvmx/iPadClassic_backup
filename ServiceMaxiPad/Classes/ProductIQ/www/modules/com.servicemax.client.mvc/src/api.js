/**
 * # Package #
 * This package provides the Command, Operation, Responder tripod that allows an application to stand in various configurations
 * where an application can trigger a named event, have a Command class created to handle it, the Command determines the current
 * registered Operation to handle that command and may do additional processing, and when all is done, the Responder delivers
 * the resulting data back to the application.
 *
 * + *Command:* An event handler and dispatcher
 * + *Operation:* A Command typically dispatches the execution of an event to an Operation that is able to connect with the data source
 * + *Responder:* A class that may process the response to the operation and will call the event handler
 * + *CommandWithResponder:* Combines a Command and Responder 
 * 
 * @class com.servicemax.client.mvc.api
 * @singleton
 * @author Indresh 
 * 
 * @copyright 2013 ServiceMax, Inc. 
 */

(function(){
	
	var mvcApi = SVMX.Package("com.servicemax.client.mvc.api");
	
	/**
	 * A Command is an event handler class that listens for a named command that is triggered via an event
	 * by an Application.
     *
     *      // This sample shows a command that is just an event handler that detects when a GET_USERINFO
     *      // event has fired and dispatches handling of it to a registered operation class.
     *      sample.Class("GetUserInfo", com.servicemax.client.mvc.api.Command, {		
     *     	    executeAsync : function(request, responder){
     *     		    this._executeOperationAsync(request, responder, {operationId : "MYAPP.GET_USERINFO"});
     *     	    }
	 *      }, {});
	 *   
	 *      // This sample shows a command that has some logic of its own
     *      sample.Class("SaveData", com.servicemax.client.mvc.api.Command, {		
     *     	    executeAsync : function(request, responder){
     *     	        var data = request.data;
     *     	        if (this.validateData(data)) {
     *     		         this._executeOperationAsync(request, responder, {operationId : "MYAPP.SAVE_DATA"});
     *     		    }
     *     	    },
     * 	        validateData : function(data) {
     * 	           if (!data.Id) return false;
     * 	           if (data.budget != data.q1 + data.q2 + data.q3 + data.q4) return false;
     * 	           return true;
     * 	        }
	 *       }, {});
	 *
	 * You should never need to create a Command; commands are automatically generated when triggerEvent is called and
	 * your class name has been configured to respond to that triggerEvent.  Your module.json file should have:
	 *
	 *     {
	 *         "type" : "com.servicemax.client.runtime.namedinstance",
     *          "config" : {
     *     	        "configure" : { "name" : "CONTROLLER", "data" : [
	 *					{"event" : "MYAPP.GET_USERINFO", "command" : "com.servicemax.client.myclass.commands.GetUserInfo"},
	 *					{"event" : "MYAPP.SAVE_DATA", "command" : "com.servicemax.client.myclass.commands.SaveData"}
	 *				]
	 *			}
	 *     }
	 *
	 * @class com.servicemax.client.mvc.api.Command
	 * @extends com.servicemax.client.lib.api.AbstractCommand
	 * 
	 */
	mvcApi.Class("Command", com.servicemax.client.lib.api.AbstractCommand, {
		__controller : null, __eventBus : null,
		
		__constructor : function(){ this.__base(); },
		setController : function(value){ this.__controller = value; },
		setEventBus : function(value){ this.__eventBus = value; },
		executeAsync : function(request, responder) { },
		
		_executeOperationAsync : function(request, responder, options){
			this.__controller.getModel().executeOperationAsync(
				request, responder, options, this.getEventBus());
		},
		
		getController : function(){ return this.__controller; },
		getEventBus : function(){ return this.__eventBus; }
	}, {});
	
	

	/**
	 * An Operation is a class that knows how to execute some process and can be configured to have Commands dispatch those processes to it.
     *
     *      // This sample shows a command that is just an event handler that detects when a GET_USERINFO
     *  	// event has fired and dispatches handling of it to a registered operation class.
     *  	sample.Class("GetFile", com.servicemax.client.mvc.api.Operation, {		
	 *     	    performAsync : function(request, responder) { 
	 *     	      	var f = new nativeservice.File(request.filePath + request.recordId);
 	 *    	      	f.read().then(function(inSuccess, inData) {
	 *     	      	    responder.result(isSuccess ? inData : null);
	 *     	      	});
	 *       	}
	 *      }, {});
	 *
	 * The `responder.result()` should ALWAYS be called, even in the event of an error.  
	 *
	 * See the Responder class for more information.
	 *
	 * You should never need to create a Operation; operations are automatically generated by com.servicemax.client.mvc.impl.Model
	 * when the Command class tries to dispatch processing to any registered operation.  Your module.json file should have:
	 *
	 *     "defines" : [
     *	    	{
     *		    	"type" : "com.servicemax.client.runtime.namedinstance",
     *			    "config" : {
     * 				    "configure" : { "name" : "MODEL", "data" : [
     *					    {"operationId" : "MYAPP.GET_FILE", "operation" : "com.servicemax.client.myapp.operations.GetFile"},
     *					    ...
     *			     	]
     *			    }
     *		    }
     *     ]
	 * @class com.servicemax.client.mvc.api.Operation
	 * @extends com.servicemax.client.lib.api.AbstractOperation
	 * 
	 */	
	mvcApi.Class("Operation", com.servicemax.client.lib.api.AbstractOperation, {
		__eventBus : null,
		__constructor : function(){ this.__base(); },
		performAsync : function(request, responder) { },
		
		setEventBus : function(value){ this.__eventBus = value; },
		getEventBus : function(){ return this.__eventBus; }
	}, {});
	
	mvcApi.Class("Responder", com.servicemax.client.lib.api.AbstractResponder, {
		__constructor : function() { this.__base(); },
		result : function(data) { },
		fault : function(data) { }
	}, {});
	
	mvcApi.Class("CommandWithResponder", mvcApi.Command, {
		__responder : null, // Optional field, in case the invoker wants to customize the callback
		__constructor : function() { this.__base(); },
        executeAsync : function(request, responder) { 
            this.__base();
            this.__responder = responder;
        },
		
		// responder
		result : function(data) { 
		    if (this.__responder) this.__responder(data);
		},
		
		fault : function(data) { }
		// end responder
		
	}, {});
})();

// end of file