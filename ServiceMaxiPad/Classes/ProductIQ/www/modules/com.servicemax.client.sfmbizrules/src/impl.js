
/**
 * Business rules engine evaluates a set of rules and returns an array of warnings and errors.
 * Depends upon expressions engine.
 * @author Michael Kantor
 * @class com.servicemax.client.sfmbizrules.impl
 * @singleton
 *
 * @copyright 2013 ServiceMax, Inc
 */

(function(){

	var appImpl = SVMX.Package("com.servicemax.client.sfmbizrules.impl");

	appImpl.Class("Module", com.servicemax.client.lib.api.ModuleActivator, {

		__constructor : function(){
			this.__base();
		},

		beforeInitialize : function(){},
		initialize : function(){},
		afterInitialize : function(){}

	}, {});

	appImpl.Class("BusinessRuleValidator", com.servicemax.client.lib.api.Object, {
		__constructor : function(){

		},

		/**
		 * PUBLIC METHOD evaluateBusinessRules
		 * @param {Object} inParams
		 *    {Object} rules Rules structure generated by getBusinessRulesHash()
		 *    {Object} data Data from sobjectinfo
		 *    {Object} fields Field definitions generated by getFieldTypes()
		 *    {Object} recordTypeMaps A hash of arrays listing the recordTypeId values for each object type
		 *    {SFMPageModel} pageModel An instance of the SFMPageModel
		 *
		 */
		evaluateBusinessRules : function(inParams) {
			var inRules = inParams.rules;
			var inData = inParams.data;
			this.fields = inParams.fields;
			this.recordTypeMaps = inParams.recordTypeMaps;
			var pageModel = inParams.pageModel;

			this.errors = [];
			this.warnings = [];

			var dataSets = {header: {lines: [inData]}};
			for (var itemKey in inData.details) {
				dataSets[itemKey] = inData.details[itemKey];
			}

			for (var itemKey in dataSets) {
				this.__evaluateBusinessRulesOnItems(dataSets[itemKey].lines, itemKey, inRules, pageModel);
			}

			this.__removeDuplicates( this.errors );
			this.__removeDuplicates( this.warnings );

            this.errors.sort( this.__sortObjectsBySequence );
            this.warnings.sort( this.__sortObjectsBySequence );

            var results = {
                errors: this.errors,
                warnings: this.warnings
            };

			delete this.errors; // Don't leave these errors/warnings to hang around
			delete this.warnings;
			delete this.fields;
			return results;
		},

        __sortObjectsBySequence: function(a, b) {
            a.sequence = parseInt(a.sequence);
            b.sequence = parseInt(b.sequence);

            return a.sequence - b.sequence;
        },

		/**
		 * PRIVATE METHOD:
		 * Don't show the same error/warning message twice.
		 */
		__removeDuplicates : function(inArray) {
			var messageHash = {};
			for (var i = inArray.length-1; i >= 0; i--) {
				var item = inArray[i];
				if (messageHash[item.message]) SVMX.array.removeElementAt(inArray, i);
				messageHash[item.message] = true;
			}
		},

		/**
		 * PRIVATE METHOD:
		 * Evaluate all rules on all items in the given lineItem (or header item)
		 */
		__evaluateBusinessRulesOnItems : function(inDataList, itemKey, inRules, inPageModel) {
			SVMX.array.forEach(inDataList, function(inDataItem) {
				inDataItem = !inPageModel ? inDataItem : inPageModel.getRawValues({
					data: inDataItem,
					referenceValue: "value",
					fieldTypes: this.fields
				});

				var isError = this.__evaluateBusinessRulesOnItem(inDataItem, itemKey, inRules, inPageModel);

				// Abort iterating over all lineitems if its an error
				if (isError && itemKey !== "header") return false;
			}, this);
		},

		/**
		 * PRIVATE METHOD:
		 * Evaluate all rules on a single Item of data
		 */
		__evaluateBusinessRulesOnItem : function(inDataItem, itemKey, inRules, inPageModel) {
			var ruleSetKey, ruleSet, itemType, itemName;
			var hasErrors = false;
			// Find the ruleSet for inDataItem
			for (itemType in inRules) {
				ruleSet = inRules[itemType];
				var key = ruleSet.key || "header";

				// If the ruleSet applies to inItemData, run all rules in the ruleset
				if (key === itemKey) {
					ruleSetKey = key;
					itemName = ruleSet.name;
					break;
				}
			}

			if (inDataItem.RecordTypeId && this.recordTypeMaps) {

			    if (ruleSet.rules.length) {
				    var tableName = ruleSet.rules[0].ruleInfo.bizRule["objectName"];//SVMX.OrgNamespace + "__Source_Object_Name__c"
				    var recordTypeMatch = SVMX.array.get(this.recordTypeMaps[tableName], function(item) {
				    	return item.recordTypeId == inDataItem.RecordTypeId ||
				    		item.name == inDataItem.RecordTypeId ||
				    		item.fixedName == inDataItem.RecordTypeId;
				    });
				    if (recordTypeMatch) inDataItem.RecordTypeId = recordTypeMatch.fixedName;
				}
			}

			// Iterate over every rule in the ruleset and validate the current item
			if (ruleSetKey) {
				SVMX.array.forEach(ruleSet.rules, function(inRule, inRuleIndex) {
					var ruleResult = this.__evaluateBusinessRuleOnItem(inRule, inDataItem);
					if (ruleResult) {
						this.__reportIssue(SVMX.cloneObject(inRule), ruleResult, inDataItem, itemName);
						if (ruleResult == "Error") {
							if (itemKey !== "header") return false; // abort forEach loop if any line items fail
							hasErrors = true;
						}
					}
				}, this);
			}

			return hasErrors;
		},

		/* PRIVATE METHOD:
		 * Takes the rule, the ruleResult (Warning, Error) and the data that was invalid
		 * and modifies the message by template substituting in values and then pushing
		 * it onto the errors or warnings array.
		 */
		__reportIssue: function(inRule, inRuleResult, inDataItem, inItemName) {
			if (!!inItemName) {
                inRule.message = inItemName + ": " + inRule.message;
            }

			inRule.message = inRule.message
				// User can use html tags but no event handlers, styles, etc... within those tags
				.replace(/\<.*?\>/g, function(inValue) {
					return inValue.replace(/\s.*$/,">");
				})

				// Strip out any forbidden tags
				.replace(/\<(object|script|style|link|embed).*?\>/gi,"")

				// Remove this once stylesheets for li are updated
				.replace(/\<li\>/g, "<li style='list-style:inherit;margin-left:20px !important;margin-top:5px !important;'>")
				// Remove this once stylesheets for ol are updated
				.replace(/\<ol\>/g, "<ol style='margin-top:10px;margin-bottom:10px;'/>")
				.replace(/\<ul\>/g, "<ul style='margin-top:10px;margin-bottom:10px;'/>")

				// This is needed to support template substituting in values from inData into the message
				.replace(/\{\{.*?\}\}/g, SVMX.proxy(this, function(inValue) {
					try {
						var text = inValue.substring(2, inValue.length - 2);
						text = text.replace(/\s/g, "_");
						var fieldName = SVMX.OrgNamespace + "__" + text + "__c";

						// Handle the case where the proper name really is "Account" instead of "SVMXC__Account__c"
						if (!(fieldName in inDataItem) && (text in inDataItem)) {
							fieldName = text;
						}

						var fieldValue = inDataItem[fieldName];
						/* Before substituting in a value, do any necessary formatting on it */
						switch (this.fields[inRule.ruleInfo.bizRule["objectName"]][fieldName]) {//SVMX.OrgNamespace + "__Source_Object_Name__c"
							case "date":
							case "datetime":
								if ("Ext" in window) {
									return Ext.Date.format(inDataItem[fieldName], Ext.Date.defaultFormat);
								} else {
									return inDataItem[fieldName];
								}
							case "int":
							case "double":
								/* Format the number, but do not lose any precision in the number */
								var v = inDataItem[fieldName];
								if ("Ext" in window) {
									return Ext.util.Format.number(v,",0") +
											String(v).indexOf(".") == -1 ? "" :
										   String(v).replace(/^.*\./, ".");
								} else {
									return v;
								}
							default:
								return fieldValue;
						}
					} catch(e) {
						return "{error}";
					}
				}));

			if (inRuleResult == "Error") {
				this.errors.push(inRule);
			} else {
				this.warnings.push(inRule);
			}
		},

		/**
		 * PRIVATE METHOD:
		 * Evaluate a single business rule on an item of data
		 */
		__evaluateBusinessRuleOnItem : function(inRule, inData) {
			var ruleElements = inRule.ruleInfo.bizRuleDetails;
			var results = [];
			var expressions = [];

			for (var i = 0; i < ruleElements.length; i++) {
				var element = ruleElements[i];
				expressions[i] = this.__generateExpression(element, inData, inRule.ruleInfo.bizRule["objectName"]);//SVMX.OrgNamespace + "__Source_Object_Name__c"
			}

			if (expressions.length > 0) {
				try {
					results = SVMX.executeExpressions(expressions, inData);
				    // Any rule that returns -1 is a rule evaluated against a null value; we ignore these results.  As true means error, we change any -1 values to false.
				    results = SVMX.array.map(results, function(item) {return SVMX.executeExpressionsResultInvalid(item) ? false : item;});
				} catch(e) {
					// results = []
				}
			}
			// TODO: Handle advanced expressions here
			var advancedExpr = inRule.ruleInfo.bizRule["advExpr"];//SVMX.OrgNamespace + "__Advance_Expression__c"
			var evalResults = false, isError = false;
			if (!results || results.length === 0) {
				isError = true;
			} else if (!advancedExpr) {
				evalResults = SVMX.array.every(results, function(inResult) {return inResult;});
			} else {
				try {
					// Replace OR with " || ", AND with " && " and all numbers with values from
					// the results array
					advancedExpr = advancedExpr.replace(/OR/ig, "||")
											   .replace(/AND/ig,"&&")
											   .replace(/NOT\s*/ig, "!")
											   .replace(/\d+/g, function(inValue) {return results[inValue-1];});
					evalResults = eval(advancedExpr);
				} catch(e) {
					SVMX.getLoggingService().getLogger("SVMX-businessrules").error("EXPR:" + advancedExpr + " fails to compile to javascript");
					isError = true;
				}
			}
			if (isError || evalResults) {
				return inRule.ruleInfo.bizRule["messageType"];//SVMX.OrgNamespace + "__Message_Type__c"
			}
		},

		/*
		 * PRIVATE METHOD:
		 * Generate expressions for the expression engine from a given rule expression
		 */
		__generateExpression : function(inElement, inData, inObjectName) {
			var baseElement = {	fieldName: inElement["field"],//SVMX.OrgNamespace + "__Field_Name__c"
								operand:   inElement["value"],//SVMX.OrgNamespace + "__Operand__c"
								operator:  inElement["operator"],//SVMX.OrgNamespace + "__Operator__c"
								parameterType: inElement["fieldType"]//SVMX.OrgNamespace + "__Parameter_Type__c"
								};
			var expression, operator, operand1, operand2,
				type1, type2, hasDateField, hasDateTimeField;

			/* Step 1: Get the type of the field we are looking at */
			type1 = this.fields[inObjectName][baseElement.fieldName];
			if (type1 === "date") hasDateField = true;
			else if (type1 === "datetime") hasDateTimeField = true;

			/* Step 2: Get the type of the field/value/constant we are comparing our field to */
			if (baseElement.parameterType === "Constant") {
				switch(baseElement.operand) {
					case "Today":
					case "Tomorrow":
					case "Yesterday":
						type2 = "date";
						hasDateField = true;
						break;
					case "Now":
						type2 = "datetime";
						hasDateTimeField = true;
						break;
					default:
						type2 = type1;
				}
			} else if (baseElement.parameterType == "Field Value") {
				type2 = this.fields[inObjectName][baseElement.operand];
				if (type2 === "date") {
                    hasDateField = true;
				} else if (type2 === "datetime") {
                    hasDateTimeField = true;
                }
			} else if (baseElement.parameterType == "Value") {
				if (type1 === "date" || type1 === "datetime") {
					if (!baseElement.operand) {
					    type2 = type1;
					} else if (baseElement.operand.length > 10) {
						type2 = "datetime";
						hasDateTimeField = true;
					} else {
						type2 = "date";
						hasDateField = true;
					}
				} else {
					type2 = type1;
				}
			}

            operand1 = this.__getOperandExpression(type1, baseElement.fieldName);

			var operationMap = {"NOTCONTAIN": "NOTCONTAINS"}; // rename some of our operations to match our expression engine.
			operator = baseElement.operator.toUpperCase();
			operator = operationMap[operator] || operator;

			/* Step 3: Generate an expression; the expression will be a little different
			 * if we are comparing a date field to a datetime field than for other types of comparisons
			 */
			if (hasDateField && hasDateTimeField &&
				SVMX.array.indexOf(["ne", "eq","lt","le","gt","ge"], baseElement.operator) != -1) {
				operator = "$DATE"+ operator;
			} else {
				operator = "$" + operator;
			}

            if (operator == "$ISNULL" || operator == "$ISNOTNULL") {
                expression = operator + "(" + operand1 + ")";
            } else {
    		    operand2 = this.__getOperandExpression(type2, baseElement.operand, baseElement.parameterType, type1);
    		    expression = operator + "(" + operand1 + "," + operand2 + ")";
    		}

			return expression;
		},

        __getOperandExpression : function(inType, inValue, inParamType, inDataType) {
            if (!!inParamType && inParamType !== "Field Value"  ) {
                //CONSTANT or LITERAL
                return  this.__prepLiteralOperand(inDataType, inValue);
            }
            //normal
            return this.__prepOperand(inType, inValue);
       	},

        __prepLiteralOperand : function(inDataType, inValue) {
            switch(inDataType) {
                case "double":
				case "int":
				case "currency":
				case "percent":
				    // Sometimes the values come in as Strings, and don't respond to === against numbers
					return "$NUMBER(" + inValue + ")";
				case "boolean":
				    var operand = typeof inValue === "string" ? "'" + inValue + "'" : inValue;
				    return "$BOOLEAN(" + operand + ")";
				case "date":
				case "datetime":
					// Dates are added to expressions through the $DATE functions
					return this.__prepDateOperand(inValue);
				default:
					// All other fields are added to expressions as quoted strings.
					// Note: No need to test for operand === 0 because thats handled above with numbers.
					if (inValue === null || inValue === undefined) {
					   return "null";
					} else {
					   return '"' +  inValue.replace(/('|")/g, "\\$1") + '"';
					}
			}
        },

        __prepDateOperand : function(inValue) {
            switch(inValue) {
                case "Tomorrow":
                    // Tomorrow
					return "$DATETOMORROW()";
				case "Today":
					return "$DATETODAY()";
				case "Yesterday":
					return "$DATEYESTERDAY()";
				case "Now":
					return "new Date()";
				default:
				    if (inValue === null) {
				        return "null";
				    } else if (typeof inValue == "string") {
				        return "$DATE('" + inValue + "')";
				    } else {
				        return "$DATE(" + inValue + ")";
				    }
            }
        },

        __prepOperand : function(inType, inValue) {
            if ((inValue === null || inValue === "") && inType != "boolean") return "null";
            switch(inType) {
                case "double":
    		    case "int":
    			case "currency":
    			case "percent":
                    return "$NUMBER(" + inValue + ")";
    			case "boolean":
    			    return "$BOOLEAN(" + inValue  + ")";
    			case "date":
    			case "datetime":
    			    return "$DATE(" + inValue + ")";
    			default:
                    return inValue;
    		}
        }
	});

})();

// end of file